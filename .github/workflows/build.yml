name: Build Artifacts

on:
  workflow_dispatch:
  push:
    tags:
      - 'v*'

permissions:
  contents: read
  actions: read
  packages: read

jobs:
  build:
    strategy:
      matrix:
        include:
          - os: windows-latest
            python: '3.11'
            mode: standalone
            spec: SBY_OST_Tool.spec
            artifact-name: sby-ost-tool-windows-standalone
            dist-path: dist/SBY_OST_Tool
            archive-name: SBY_OST_Tool-windows-standalone.zip
          - os: windows-latest
            python: '3.11'
            mode: streaming
            spec: SBY_OST_Tool_Remote.spec
            artifact-name: sby-ost-tool-windows-streaming
            dist-path: dist/SBY_OST_Tool_Remote
            archive-name: SBY_OST_Tool-windows-streaming.zip
          - os: ubuntu-latest
            python: '3.11'
            mode: standalone
            spec: SBY_OST_Tool_Linux.spec
            artifact-name: sby-ost-tool-linux-standalone
            dist-path: dist/SBY_OST_Tool
            archive-name: SBY_OST_Tool-linux-standalone.tar.gz
          - os: ubuntu-latest
            python: '3.11'
            mode: streaming
            spec: SBY_OST_Tool_Remote_Linux.spec
            artifact-name: sby-ost-tool-linux-streaming
            dist-path: dist/SBY_OST_Tool_Remote
            archive-name: SBY_OST_Tool-linux-streaming.tar.gz
          - os: macos-latest
            python: '3.11'
            mode: standalone
            spec: SBY_OST_Tool_Mac.spec
            artifact-name: sby-ost-tool-macos-standalone
            dist-path: dist/SBY_OST_Tool.app
            archive-name: SBY_OST_Tool-macos-standalone.zip
          - os: macos-latest
            python: '3.11'
            mode: streaming
            spec: SBY_OST_Tool_Remote_Mac.spec
            artifact-name: sby-ost-tool-macos-streaming
            dist-path: dist/SBY_OST_Tool_Remote.app
            archive-name: SBY_OST_Tool-macos-streaming.zip
    runs-on: ${{ matrix.os }}

    env:
      PIP_DISABLE_PIP_VERSION_CHECK: '1'
      PYTHONDONTWRITEBYTECODE: '1'
      SBY_ASSET_MODE: ${{ matrix.mode == 'streaming' && 'remote' || '' }}
      SBY_R2_BASE_URL: ${{ secrets.SBY_R2_BASE_URL }}
      SBY_R2_PREFIX: ${{ secrets.SBY_R2_PREFIX }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          lfs: ${{ matrix.mode == 'standalone' }}

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.python }}

      - name: Install system dependencies (Linux)
        if: startsWith(matrix.os, 'ubuntu')
        run: |
          sudo apt-get update
          sudo apt-get install -y python3-dev libgl1-mesa-dev libxkbcommon-x11-0 libpulse-dev libasound2-dev

      - name: Install build tooling
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install pyinstaller pillow
      
      - name: Generate multi-resolution Windows icon
        if: startsWith(matrix.os, 'windows')
        shell: python
        run: |
          from PIL import Image
          
          img = Image.open('icon.png')
          icon_sizes = [(16, 16), (32, 32), (48, 48), (64, 64), (128, 128), (256, 256)]
          img.save('icon.ico', format='ICO', sizes=icon_sizes)
          print(f"Generated multi-resolution icon.ico with sizes: {icon_sizes}")

      - name: Generate macOS iconset
        if: matrix.os == 'macos-latest'
        shell: python
        run: |
          import os
          from pathlib import Path
          from PIL import Image
          
          source_img = Image.open('icon.png')
          ICNS_SIZES = [16, 32, 64, 128, 256]
          iconset = Path('icon.iconset')
          iconset.mkdir(exist_ok=True)
          
          for size in ICNS_SIZES:
              resized = source_img.resize((size, size), Image.LANCZOS)
              resized.save(iconset / f'icon_{size}x{size}.png')
              if size <= 128:
                  resized2 = source_img.resize((size * 2, size * 2), Image.LANCZOS)
                  resized2.save(iconset / f'icon_{size}x{size}@2x.png')
          
          print("Generated macOS iconset")
      
      - name: Convert iconset to icns
        if: matrix.os == 'macos-latest'
        run: |
          iconutil -c icns icon.iconset
          rm -rf icon.iconset
          ls -lh icon.icns

      - name: Write runtime config
        shell: python
        env:
          BUILD_MODE: ${{ matrix.mode }}
          R2_BASE_URL: ${{ secrets.SBY_R2_BASE_URL }}
          R2_PREFIX: ${{ secrets.SBY_R2_PREFIX }}
        run: |
          import json
          import os
          from pathlib import Path
          config = {}
          if os.environ.get("BUILD_MODE") == "streaming":
              base_url = os.environ.get("R2_BASE_URL", "").strip().strip('"\'')
              prefix = os.environ.get("R2_PREFIX", "").strip().strip('"\'')
              config["asset_mode"] = "remote"
              config["r2_base_url"] = base_url
              config["r2_prefix"] = prefix
          Path("runtime_config.json").write_text(json.dumps(config, indent=2))

      - name: Compile sources
        run: python -m compileall soundtrack_tool rename.py

      - name: Build artifact
        run: pyinstaller ${{ matrix.spec }} --noconfirm --clean

      - name: Fix macOS executable permissions
        if: matrix.os == 'macos-latest'
        run: |
          chmod +x "${{ matrix.dist-path }}/Contents/MacOS/"*

      - name: Fix malformed Qt frameworks and clean metadata
        if: matrix.os == 'macos-latest'
        run: |
          # Use absolute path to avoid directory issues
          APP_BUNDLE="${{ github.workspace }}/${{ matrix.dist-path }}"
          
          echo "Removing extended attributes that prevent signing..."
          xattr -cr "$APP_BUNDLE"
          
          echo "Restructuring Qt frameworks for signing and runtime..."
          # PyInstaller copies Qt frameworks with malformed bundle structure that can't be signed as frameworks
          # But the actual Qt dylibs inside them are needed at runtime
          # Solution: Extract the dylibs from the frameworks and place them where @rpath can find them
          QT_FRAMEWORKS_DIR="$APP_BUNDLE/Contents/Frameworks/PySide6/Qt/lib"
          if [ -d "$QT_FRAMEWORKS_DIR" ]; then
            echo "Found Qt frameworks directory, extracting dylibs..."
            
            # For each .framework, extract the main dylib to the Qt/lib directory
            for framework in "$QT_FRAMEWORKS_DIR"/*.framework; do
              if [ -d "$framework" ]; then
                FRAMEWORK_NAME=$(basename "$framework" .framework)
                echo "  Processing $FRAMEWORK_NAME.framework..."
                
                # Find the actual dylib inside the framework (usually in Versions/A/ or Versions/5/)
                DYLIB_PATH=""
                if [ -f "$framework/Versions/A/$FRAMEWORK_NAME" ]; then
                  DYLIB_PATH="$framework/Versions/A/$FRAMEWORK_NAME"
                elif [ -f "$framework/Versions/5/$FRAMEWORK_NAME" ]; then
                  DYLIB_PATH="$framework/Versions/5/$FRAMEWORK_NAME"
                elif [ -f "$framework/$FRAMEWORK_NAME" ]; then
                  DYLIB_PATH="$framework/$FRAMEWORK_NAME"
                fi
                
                # Copy the dylib to Qt/lib directory if found
                if [ -n "$DYLIB_PATH" ] && [ -f "$DYLIB_PATH" ]; then
                  cp "$DYLIB_PATH" "$QT_FRAMEWORKS_DIR/$FRAMEWORK_NAME.dylib"
                  echo "    ✓ Extracted $FRAMEWORK_NAME.dylib"
                fi
              fi
            done
            
            # Now remove the malformed .framework bundles (we've extracted what we need)
            FRAMEWORK_COUNT=$(find "$QT_FRAMEWORKS_DIR" -name "*.framework" -type d -maxdepth 1 | wc -l | tr -d ' ')
            if [ "$FRAMEWORK_COUNT" -gt 0 ]; then
              echo "Removing $FRAMEWORK_COUNT malformed Qt framework bundles..."
              find "$QT_FRAMEWORKS_DIR" -name "*.framework" -type d -maxdepth 1 -exec rm -rf {} + 2>/dev/null || true
              echo "✓ Removed malformed Qt framework bundles (dylibs extracted)"
            fi
            
            # Fix @rpath references in PySide6 .so files to point to Qt dylibs
            echo "Fixing @rpath references in PySide6 binaries..."
            PYSIDE6_DIR="$APP_BUNDLE/Contents/Frameworks/PySide6"
            if [ -d "$PYSIDE6_DIR" ]; then
              # Update rpath in all .so files to include Qt/lib directory
              find "$PYSIDE6_DIR" -name "*.so" -type f | while read sofile; do
                # Add rpath to Qt/lib directory (relative to the .so file location)
                install_name_tool -add_rpath "@loader_path/Qt/lib" "$sofile" 2>/dev/null || true
                
                # Also fix any absolute Qt framework references to point to the extracted dylibs
                # Change @rpath/QtCore -> @rpath/QtCore.dylib for each Qt library
                for qtlib in QtCore QtGui QtWidgets QtQml QtQuick QtNetwork QtMultimedia QtOpenGL Qt3DCore Qt3DRender Qt3DInput Qt3DLogic Qt3DAnimation Qt3DExtras QtConcurrent QtDBus QtOpenGLWidgets QtPrintSupport QtSql QtSvg QtTest QtXml; do
                  install_name_tool -change "@rpath/$qtlib" "@rpath/$qtlib.dylib" "$sofile" 2>/dev/null || true
                done
              done
              echo "✓ Fixed @rpath references in PySide6 binaries"
              
              # Fix Qt dylibs' own dependencies and install names
              echo "Fixing Qt dylib inter-dependencies..."
              if [ -d "$QT_FRAMEWORKS_DIR" ]; then
                for dylib in "$QT_FRAMEWORKS_DIR"/*.dylib; do
                  if [ -f "$dylib" ]; then
                    DYLIB_NAME=$(basename "$dylib")
                    
                    # Update the dylib's install name to use @rpath
                    install_name_tool -id "@rpath/$DYLIB_NAME" "$dylib" 2>/dev/null || true
                    
                    # Fix dependencies on other Qt libraries
                    for qtlib in QtCore QtGui QtWidgets QtQml QtQuick QtNetwork QtMultimedia QtOpenGL Qt3DCore Qt3DRender Qt3DInput Qt3DLogic Qt3DAnimation Qt3DExtras QtConcurrent QtDBus QtOpenGLWidgets QtPrintSupport QtSql QtSvg QtTest QtXml; do
                      # Change @rpath/QtXxx to @rpath/QtXxx.dylib
                      install_name_tool -change "@rpath/$qtlib" "@rpath/$qtlib.dylib" "$dylib" 2>/dev/null || true
                      # Also handle framework-style paths
                      install_name_tool -change "@rpath/$qtlib.framework/Versions/A/$qtlib" "@rpath/$qtlib.dylib" "$dylib" 2>/dev/null || true
                    done
                  fi
                done
                echo "✓ Fixed Qt dylib inter-dependencies"
              fi
            fi
          fi
          
          echo "✓ App bundle cleaned and restructured for signing"

      - name: Import Code Signing Certificate
        if: matrix.os == 'macos-latest'
        env:
          MACOS_CERTIFICATE: ${{ secrets.MACOS_CERTIFICATE }}
          MACOS_CERTIFICATE_PASSWORD: ${{ secrets.MACOS_CERTIFICATE_PASSWORD }}
        run: |
          # Create temporary keychain for signing
          KEYCHAIN_PATH=$RUNNER_TEMP/app-signing.keychain-db
          KEYCHAIN_PASSWORD=$(openssl rand -base64 32)
          
          # Decode the certificate from base64
          echo "$MACOS_CERTIFICATE" | base64 --decode > certificate.p12
          
          # Create temporary keychain
          security create-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security set-keychain-settings -lut 21600 "$KEYCHAIN_PATH"
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          
          # Import certificate to keychain
          security import certificate.p12 -k "$KEYCHAIN_PATH" -P "$MACOS_CERTIFICATE_PASSWORD" -T /usr/bin/codesign
          security list-keychain -d user -s "$KEYCHAIN_PATH"
          
          # Allow codesign to access keychain
          security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          
          # Clean up certificate file
          rm certificate.p12
          
          # Store keychain path for cleanup
          echo "KEYCHAIN_PATH=$KEYCHAIN_PATH" >> $GITHUB_ENV
          echo "✓ Code signing certificate imported successfully"

      - name: Sign macOS app bundle with Developer ID
        if: matrix.os == 'macos-latest'
        env:
          DEVELOPER_ID: ${{ secrets.APPLE_DEVELOPER_ID }}
        run: |
          # Use absolute path to avoid directory issues
          APP_BUNDLE="${{ github.workspace }}/${{ matrix.dist-path }}"
          
          echo "Signing with Apple Developer ID: $DEVELOPER_ID"
          echo "App bundle path: $APP_BUNDLE"
          
          # Verify app bundle exists before signing
          if [ ! -d "$APP_BUNDLE" ]; then
            echo "ERROR: App bundle not found at $APP_BUNDLE"
            ls -la "${{ github.workspace }}/dist/" || echo "dist directory not found"
            exit 1
          fi
          
          # IMPORTANT: Sign from the inside out, WITHOUT using --deep on frameworks
          # The --deep flag can break symlinks in properly structured frameworks like Python.framework
          
          # 1. Sign all dylibs and binaries in Frameworks directory
          echo "Signing framework binaries and libraries..."
          if [ -d "$APP_BUNDLE/Contents/Frameworks" ]; then
            # Find and sign all .dylib files
            find "$APP_BUNDLE/Contents/Frameworks" -type f -name "*.dylib" -exec codesign --force --sign "$DEVELOPER_ID" --options runtime --timestamp {} \; 2>&1 | grep -v "already signed" || true
            
            # Find and sign all .so files (Python extensions)
            find "$APP_BUNDLE/Contents/Frameworks" -type f -name "*.so" -exec codesign --force --sign "$DEVELOPER_ID" --options runtime --timestamp {} \; 2>&1 | grep -v "already signed" || true
            
            # Sign Python.framework (properly structured framework - NO --deep)
            if [ -d "$APP_BUNDLE/Contents/Frameworks/Python.framework" ]; then
              echo "Signing Python.framework..."
              # Sign the Python executable inside the framework
              if [ -f "$APP_BUNDLE/Contents/Frameworks/Python.framework/Versions/Current/Python" ]; then
                codesign --force --sign "$DEVELOPER_ID" --options runtime --timestamp "$APP_BUNDLE/Contents/Frameworks/Python.framework/Versions/Current/Python"
              fi
              # Sign the framework bundle itself (without --deep to preserve symlinks)
              codesign --force --sign "$DEVELOPER_ID" --options runtime --timestamp "$APP_BUNDLE/Contents/Frameworks/Python.framework"
            fi
            
            # Sign any other properly structured frameworks
            find "$APP_BUNDLE/Contents/Frameworks" -name "*.framework" -type d -depth 1 -exec codesign --force --sign "$DEVELOPER_ID" --options runtime --timestamp {} \; 2>&1 | grep -v "already signed" || true
          fi
          
          # 2. Sign any executables in MacOS directory
          echo "Signing main executable(s)..."
          for executable in "$APP_BUNDLE/Contents/MacOS/"*; do
            if [ -f "$executable" ]; then
              echo "  Signing: $(basename $executable)"
              codesign --force --sign "$DEVELOPER_ID" --options runtime --timestamp --entitlements entitlements.plist "$executable"
            fi
          done
          
          # 3. Sign the entire app bundle WITHOUT --deep
          # This is the critical fix: --deep can break symlinks and cause "No such file or directory" errors
          echo "Signing entire app bundle (without --deep to preserve bundle integrity)..."
          codesign --force --sign "$DEVELOPER_ID" --options runtime --timestamp --entitlements entitlements.plist "$APP_BUNDLE"
          
          echo "✓ App bundle signed successfully"
          
          # Verify signature (without --strict initially to see any issues)
          echo "Verifying signature..."
          codesign --verify --verbose=2 "$APP_BUNDLE" 2>&1 || {
            echo "⚠ Basic verification failed, trying without verbose..."
            codesign --verify "$APP_BUNDLE" || {
              echo "ERROR: Signature verification failed"
              exit 1
            }
          }
          echo "✓ Signature verified"
          
          # Display signature info
          echo ""
          echo "=== Signature Details ==="
          codesign -dvvv "$APP_BUNDLE" 2>&1 | head -30

      - name: Notarize macOS app bundle
        if: matrix.os == 'macos-latest'
        env:
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
          APPLE_APP_PASSWORD: ${{ secrets.APPLE_APP_PASSWORD }}
        run: |
          echo "Creating zip for notarization..."
          cd dist
          ditto -c -k --keepParent "$(basename ${{ matrix.dist-path }})" notarization.zip
          
          echo "Submitting app for notarization..."
          xcrun notarytool submit notarization.zip \
            --apple-id "$APPLE_ID" \
            --team-id "$APPLE_TEAM_ID" \
            --password "$APPLE_APP_PASSWORD" \
            --wait \
            --timeout 30m
          
          # Check if notarization succeeded
          if [ $? -eq 0 ]; then
            echo "✓ Notarization successful"
            
            # Staple the notarization ticket to the app (we're in dist/ directory)
            APP_NAME="$(basename ${{ matrix.dist-path }})"
            xcrun stapler staple "$APP_NAME"
            echo "✓ Notarization ticket stapled to app"
            
            # Verify stapling
            xcrun stapler validate "$APP_NAME"
            echo "✓ Stapling verified"
          else
            echo "⚠ Notarization failed or timed out"
            echo "The app is signed but not notarized. Users will see a warning on first launch."
          fi
          
          # Clean up notarization zip
          rm notarization.zip
          cd ..

      - name: Cleanup keychain
        if: matrix.os == 'macos-latest' && always()
        run: |
          if [ -n "$KEYCHAIN_PATH" ]; then
            security delete-keychain "$KEYCHAIN_PATH" || true
          fi

      - name: Verify app bundle size (macOS)
        if: matrix.os == 'macos-latest'
        run: |
          echo "=== App Bundle Size Breakdown ==="
          du -sh "${{ matrix.dist-path }}"
          echo ""
          echo "=== Contents Directory Sizes ==="
          du -sh "${{ matrix.dist-path }}/Contents/"*
          echo ""
          echo "=== Checking for PySide6 duplication ==="
          if [ -d "${{ matrix.dist-path }}/Contents/Resources/PySide6" ]; then
            echo "WARNING: PySide6 found in Resources (should only be in Frameworks):"
            du -sh "${{ matrix.dist-path }}/Contents/Resources/PySide6"
          else
            echo "✓ No PySide6 in Resources (correct)"
          fi
          if [ -d "${{ matrix.dist-path }}/Contents/Frameworks/PySide6" ]; then
            echo "✓ PySide6 found in Frameworks:"
            du -sh "${{ matrix.dist-path }}/Contents/Frameworks/PySide6"
          fi

      - name: Create archive (macOS)
        if: matrix.os == 'macos-latest'
        run: |
          cd dist
          ditto -c -k --sequesterRsrc --keepParent "$(basename ${{ matrix.dist-path }})" "../${{ matrix.archive-name }}"
          cd ..
          echo "Created archive: ${{ matrix.archive-name }}"
          ls -lh "${{ matrix.archive-name }}"

      - name: Create archive (Linux)
        if: startsWith(matrix.os, 'ubuntu')
        run: |
          cd dist
          tar -czf "../${{ matrix.archive-name }}" "$(basename ${{ matrix.dist-path }})"
          cd ..

      - name: Upload artifact (Windows)
        if: startsWith(matrix.os, 'windows')
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.artifact-name }}
          path: ${{ matrix.dist-path }}
          if-no-files-found: error
          overwrite: true

      - name: Upload artifact (Linux/macOS)
        if: matrix.os != 'windows-latest'
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.artifact-name }}
          path: ${{ matrix.archive-name }}
          if-no-files-found: error
          overwrite: true
