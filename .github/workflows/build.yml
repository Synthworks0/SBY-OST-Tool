name: Build Artifacts

on:
  workflow_dispatch:
  push:
    tags:
      - 'v*'

permissions:
  contents: read
  actions: read
  packages: read

jobs:
  build:
    strategy:
      matrix:
        include:
          - os: windows-latest
            python: '3.11'
            mode: standalone
            spec: build/specs/windows/SBY_OST_Tool.spec
            artifact-name: sby-ost-tool-windows-standalone
            dist-path: dist/SBY_OST_Tool
            archive-name: SBY_OST_Tool-windows-standalone.zip
          - os: windows-latest
            python: '3.11'
            mode: streaming
            spec: build/specs/windows/SBY_OST_Tool_Remote.spec
            artifact-name: sby-ost-tool-windows-streaming
            dist-path: dist/SBY_OST_Tool_Remote
            archive-name: SBY_OST_Tool-windows-streaming.zip
          - os: ubuntu-latest
            python: '3.11'
            mode: standalone
            spec: build/specs/linux/SBY_OST_Tool_Linux.spec
            artifact-name: sby-ost-tool-linux-standalone
            dist-path: dist/SBY_OST_Tool
            archive-name: SBY_OST_Tool-linux-standalone.tar.gz
          - os: ubuntu-latest
            python: '3.11'
            mode: streaming
            spec: build/specs/linux/SBY_OST_Tool_Remote_Linux.spec
            artifact-name: sby-ost-tool-linux-streaming
            dist-path: dist/SBY_OST_Tool_Remote
            archive-name: SBY_OST_Tool-linux-streaming.tar.gz
          - os: macos-latest
            python: '3.11'
            mode: standalone
            spec: build/specs/macos/SBY_OST_Tool_Mac.spec
            artifact-name: sby-ost-tool-macos-standalone
            dist-path: dist/SBY_OST_Tool.app
            archive-name: SBY_OST_Tool-macos-standalone.zip
          - os: macos-latest
            python: '3.11'
            mode: streaming
            spec: build/specs/macos/SBY_OST_Tool_Remote_Mac.spec
            artifact-name: sby-ost-tool-macos-streaming
            dist-path: dist/SBY_OST_Tool_Remote.app
            archive-name: SBY_OST_Tool-macos-streaming.zip
    runs-on: ${{ matrix.os }}

    env:
      PIP_DISABLE_PIP_VERSION_CHECK: '1'
      PYTHONDONTWRITEBYTECODE: '1'
      SBY_ASSET_MODE: ${{ matrix.mode == 'streaming' && 'remote' || '' }}
      SBY_R2_BASE_URL: ${{ secrets.SBY_R2_BASE_URL }}
      SBY_R2_PREFIX: ${{ secrets.SBY_R2_PREFIX }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          lfs: ${{ matrix.mode == 'standalone' }}

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.python }}

      - name: Install system dependencies (Linux)
        if: startsWith(matrix.os, 'ubuntu')
        run: |
          sudo apt-get update
          sudo apt-get install -y python3-dev libgl1-mesa-dev libxkbcommon-x11-0 libpulse-dev libasound2-dev

      - name: Install build tooling
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install pyinstaller pillow
      
      - name: Generate multi-resolution Windows icon
        if: startsWith(matrix.os, 'windows')
        shell: python
        run: |
          from PIL import Image
          
          img = Image.open('icon.png')
          icon_sizes = [(16, 16), (32, 32), (48, 48), (64, 64), (128, 128), (256, 256)]
          img.save('icon.ico', format='ICO', sizes=icon_sizes)
          print(f"Generated multi-resolution icon.ico with sizes: {icon_sizes}")

      - name: Generate macOS iconset
        if: matrix.os == 'macos-latest'
        shell: python
        run: |
          import os
          from pathlib import Path
          from PIL import Image
          
          source_img = Image.open('icon.png')
          ICNS_SIZES = [16, 32, 64, 128, 256]
          iconset = Path('icon.iconset')
          iconset.mkdir(exist_ok=True)
          
          for size in ICNS_SIZES:
              resized = source_img.resize((size, size), Image.LANCZOS)
              resized.save(iconset / f'icon_{size}x{size}.png')
              if size <= 128:
                  resized2 = source_img.resize((size * 2, size * 2), Image.LANCZOS)
                  resized2.save(iconset / f'icon_{size}x{size}@2x.png')
          
          print("Generated macOS iconset")
      
      - name: Convert iconset to icns
        if: matrix.os == 'macos-latest'
        run: |
          iconutil -c icns icon.iconset
          rm -rf icon.iconset
          ls -lh icon.icns

      - name: Write runtime config
        shell: python
        env:
          BUILD_MODE: ${{ matrix.mode }}
          R2_BASE_URL: ${{ secrets.SBY_R2_BASE_URL }}
          R2_PREFIX: ${{ secrets.SBY_R2_PREFIX }}
        run: |
          import json
          import os
          from pathlib import Path
          config = {}
          if os.environ.get("BUILD_MODE") == "streaming":
              base_url = os.environ.get("R2_BASE_URL", "").strip().strip('"\'')
              prefix = os.environ.get("R2_PREFIX", "").strip().strip('"\'')
              config["asset_mode"] = "remote"
              config["r2_base_url"] = base_url
              config["r2_prefix"] = prefix
          Path("runtime_config.json").write_text(json.dumps(config, indent=2))

      - name: Compile sources
        run: python -m compileall soundtrack_tool main.py

      - name: Build artifact
        run: pyinstaller ${{ matrix.spec }} --noconfirm --clean

      - name: Fix macOS executable permissions
        if: matrix.os == 'macos-latest'
        run: |
          chmod +x "${{ matrix.dist-path }}/Contents/MacOS/"*

      - name: Normalize asset filenames to NFD (macOS)
        if: matrix.os == 'macos-latest'
        run: |
          echo "=== Normalizing asset filenames to NFD (decomposed Unicode) ==="
          python3 - <<'NORMALIZE_PY'
          import os
          import unicodedata
          from pathlib import Path
          
          def normalize_to_nfd(path):
              """Recursively rename all files/dirs to NFD (decomposed) form."""
              path = Path(path)
              
              # Process children first (depth-first) to avoid renaming parent before children
              if path.is_dir():
                  for child in sorted(path.iterdir(), reverse=True):
                      normalize_to_nfd(child)
              
              # Normalize this path's name
              original_name = path.name
              nfd_name = unicodedata.normalize('NFD', original_name)
              
              if original_name != nfd_name:
                  new_path = path.parent / nfd_name
                  print(f"Renaming: {original_name} -> {nfd_name}")
                  path.rename(new_path)
                  return new_path
              return path
          
          # Normalize all assets in the standalone build
          assets_dir = Path("${{ matrix.dist-path }}/Contents/Resources/soundtrack_tool/assets")
          if assets_dir.exists():
              print(f"Normalizing assets in: {assets_dir}")
              normalize_to_nfd(assets_dir)
              print("✓ NFD normalization complete")
          else:
              print(f"⚠ Assets directory not found (expected for Remote build): {assets_dir}")
          NORMALIZE_PY

      - name: Prepare macOS app bundle for signing
        if: matrix.os == 'macos-latest'
        run: |
          # Use absolute path to avoid directory issues
          APP_BUNDLE="${{ github.workspace }}/${{ matrix.dist-path }}"
          
          if [ ! -d "$APP_BUNDLE" ]; then
            echo "ERROR: App bundle not found at $APP_BUNDLE"
            ls -la "${{ github.workspace }}/dist" || true
            exit 1
          fi

          echo "Clearing extended attributes that prevent signing..."
          xattr -cr "$APP_BUNDLE"
          
          echo ""
          echo "=== Removing PyInstaller's ad-hoc signatures ==="
          # PyInstaller signs the bundle with ad-hoc signatures during build
          # These MUST be removed before applying Developer ID signatures
          echo "  Removing bundle signature..."
          codesign --remove-signature "$APP_BUNDLE" 2>/dev/null || true
          
          echo "  Removing framework signatures..."
          find "$APP_BUNDLE/Contents/Frameworks" -type d -name "*.framework" 2>/dev/null | while read fw; do
            codesign --remove-signature "$fw" 2>/dev/null || true
          done
          
          echo "  Removing library signatures..."  
          find "$APP_BUNDLE/Contents" -type f \( -name "*.dylib" -o -name "*.so" \) 2>/dev/null | while read lib; do
            codesign --remove-signature "$lib" 2>/dev/null || true
          done
          
          echo "  ✓ All existing signatures removed - ready for Developer ID signing"

          echo "Verifying required PySide6 assets are present..."
          QML_LOCATIONS=(
            "$APP_BUNDLE/Contents/Resources/PySide6/Qt/qml"
            "$APP_BUNDLE/Contents/MacOS/PySide6/Qt/qml"
            "$APP_BUNDLE/Contents/Frameworks/PySide6/Qt/qml"
          )
          PLUGIN_LOCATIONS=(
            "$APP_BUNDLE/Contents/Frameworks/PySide6/Qt/plugins"
            "$APP_BUNDLE/Contents/Resources/PySide6/Qt/plugins"
            "$APP_BUNDLE/Contents/MacOS/PySide6/Qt/plugins"
          )

          has_qml="false"
          for path in "${QML_LOCATIONS[@]}"; do
            if [ -d "$path" ]; then
              has_qml="true"
              break
            fi
          done
          if [ "$has_qml" != "true" ]; then
            echo "ERROR: PySide6 QML modules were not bundled. Check spec datas configuration."
            ls -R "$APP_BUNDLE/Contents" | head -200 || true
            exit 1
          fi

          has_plugins="false"
          for path in "${PLUGIN_LOCATIONS[@]}"; do
            if [ -d "$path" ]; then
              has_plugins="true"
              break
            fi
          done
          if [ "$has_plugins" != "true" ]; then
            echo "ERROR: PySide6 plugins were not bundled. Check spec binaries configuration."
            ls -R "$APP_BUNDLE/Contents" | head -200 || true
            exit 1
          fi

          echo "Ensuring executable bits are set on bundled binaries..."
          find "$APP_BUNDLE/Contents" -type f \( -name "*.dylib" -o -name "*.so" -o -path "*/MacOS/*" \) -exec chmod +x {} +

          echo "✓ App bundle prepared for signing"

      - name: Import Code Signing Certificate
        if: matrix.os == 'macos-latest'
        env:
          MACOS_CERTIFICATE: ${{ secrets.MACOS_CERTIFICATE }}
          MACOS_CERTIFICATE_PASSWORD: ${{ secrets.MACOS_CERTIFICATE_PASSWORD }}
        run: |
          # Create temporary keychain for signing
          KEYCHAIN_PATH=$RUNNER_TEMP/app-signing.keychain-db
          KEYCHAIN_PASSWORD=$(openssl rand -base64 32)
          
          # Decode the certificate from base64
          echo "$MACOS_CERTIFICATE" | base64 --decode > certificate.p12
          
          # Create temporary keychain
          security create-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security set-keychain-settings -lut 21600 "$KEYCHAIN_PATH"
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          
          # Import certificate to keychain
          security import certificate.p12 -k "$KEYCHAIN_PATH" -P "$MACOS_CERTIFICATE_PASSWORD" -T /usr/bin/codesign
          security list-keychain -d user -s "$KEYCHAIN_PATH"
          
          # Allow codesign to access keychain
          security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          
          # Clean up certificate file
          rm certificate.p12
          
          # Store keychain path for cleanup
          echo "KEYCHAIN_PATH=$KEYCHAIN_PATH" >> $GITHUB_ENV
          echo "✓ Code signing certificate imported successfully"

      - name: Sign macOS app bundle with Developer ID
        if: matrix.os == 'macos-latest'
        env:
          DEVELOPER_ID: ${{ secrets.APPLE_DEVELOPER_ID }}
        run: |
          # Use absolute path to avoid directory issues
          APP_BUNDLE="${{ github.workspace }}/${{ matrix.dist-path }}"
          
          echo "Signing with Apple Developer ID: $DEVELOPER_ID"
          echo "App bundle path: $APP_BUNDLE"
          
          # Verify app bundle exists before signing
          if [ ! -d "$APP_BUNDLE" ]; then
            echo "ERROR: App bundle not found at $APP_BUNDLE"
            ls -la "${{ github.workspace }}/dist/" || echo "dist directory not found"
            exit 1
          fi
          
          # CRITICAL FIX: The --force flag isn't the issue - PyInstaller already signs components
          # The KEY is signing ALL nested content BEFORE the final bundle seal
          # macOS validates the seal by checking if Resources was modified after signing
          
          echo "=== Phase 1: Sign all frameworks (deepest first) ==="
          # Sign Python.framework first
          if [ -d "$APP_BUNDLE/Contents/Frameworks/Python.framework" ]; then
            echo "  Signing Python.framework..."
            codesign --force --sign "$DEVELOPER_ID" --options runtime --timestamp \
              "$APP_BUNDLE/Contents/Frameworks/Python.framework" || true
          fi
          
          # Sign Qt frameworks if present
          if [ -d "$APP_BUNDLE/Contents/Frameworks/PySide6/Qt/lib" ]; then
            echo "  Signing Qt frameworks..."
            find "$APP_BUNDLE/Contents/Frameworks/PySide6/Qt/lib" -type d -name "*.framework" 2>/dev/null | while read fw; do
              codesign --force --sign "$DEVELOPER_ID" --options runtime --timestamp "$fw" 2>/dev/null || true
            done
            echo "    ✓ Qt frameworks signed"
          fi

          echo ""
          echo "=== Phase 2: Sign all dynamic libraries ==="
          # Sign all .dylib and .so files
          echo "  Signing dylibs and shared objects..."
          find "$APP_BUNDLE/Contents" -type f \( -name "*.dylib" -o -name "*.so" \) 2>/dev/null | while read lib; do
            codesign --force --sign "$DEVELOPER_ID" --options runtime --timestamp "$lib" 2>/dev/null || true
          done
          echo "  ✓ All libraries signed"

          echo ""
          echo "=== Phase 3: Sign main executable with entitlements ==="
          for executable in "$APP_BUNDLE/Contents/MacOS/"*; do
            if [ -f "$executable" ] && [ -x "$executable" ]; then
              echo "  Signing executable: $(basename "$executable")"
              codesign --force --sign "$DEVELOPER_ID" --options runtime --timestamp \
                --entitlements build/entitlements.plist "$executable"
              codesign --verify --strict "$executable" && echo "    ✓ Verified"
            fi
          done

          echo ""
          echo "=== Phase 4: FINAL - Sign entire app bundle to create seal ==="
          # This creates the CodeResources file that seals Contents/Resources
          # MUST be done LAST after all components are signed
          echo "  Creating final bundle seal with entitlements..."
          codesign --force --deep --sign "$DEVELOPER_ID" --options runtime --timestamp \
            --entitlements build/entitlements.plist "$APP_BUNDLE"
          
          echo ""
          echo "=== Verifying final bundle signature ==="
          # Deep verification to ensure all nested signatures are intact
          if codesign --verify --deep --strict --verbose=2 "$APP_BUNDLE" 2>&1; then
            echo "✓ Complete bundle signature verified successfully"
          else
            echo "ERROR: Bundle signature verification failed"
            exit 1
          fi

          # Display detailed signature info
          echo ""
          echo "=== Signature Details ==="
          codesign -dvvv "$APP_BUNDLE" 2>&1 | head -30

      - name: Notarize macOS app bundle
        if: matrix.os == 'macos-latest'
        env:
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
          APPLE_APP_PASSWORD: ${{ secrets.APPLE_APP_PASSWORD }}
        run: |
          echo "Creating zip for notarization..."
          cd dist
          ditto -c -k --keepParent "$(basename ${{ matrix.dist-path }})" notarization.zip
          
          echo "Submitting app for notarization..."
          if xcrun notarytool submit notarization.zip \
            --apple-id "$APPLE_ID" \
            --team-id "$APPLE_TEAM_ID" \
            --password "$APPLE_APP_PASSWORD" \
            --wait \
            --timeout 30m; then
            echo "✓ Notarization successful"
            
            # Staple the notarization ticket to the app (we're in dist/ directory)
            APP_NAME="$(basename ${{ matrix.dist-path }})"
            xcrun stapler staple "$APP_NAME"
            echo "✓ Notarization ticket stapled to app"
            
            # Verify stapling
            xcrun stapler validate "$APP_NAME"
            echo "✓ Stapling verified"

            echo "Running Gatekeeper assessment..."
            spctl --assess --type exec --verbose "$APP_NAME"
            echo "✓ Gatekeeper assessment passed"
          else
            echo "⚠ Notarization failed or timed out"
            echo "The app is signed but not notarized. Users will see a warning on first launch."
          fi
          
          # Clean up notarization zip
          rm notarization.zip
          cd ..

      - name: Cleanup keychain
        if: matrix.os == 'macos-latest' && always()
        run: |
          if [ -n "$KEYCHAIN_PATH" ]; then
            security delete-keychain "$KEYCHAIN_PATH" || true
          fi

      - name: Verify app bundle structure and signatures (macOS)
        if: matrix.os == 'macos-latest'
        run: |
          echo "=== App Bundle Size Breakdown ==="
          du -sh "${{ matrix.dist-path }}"
          echo ""
          echo "=== Contents Directory Sizes ==="
          du -sh "${{ matrix.dist-path }}/Contents/"*
          echo ""
          echo "=== Verifying Code Signature Seal Integrity (CRITICAL) ==="
          # Comprehensive signature verification - this is the real test
          if codesign --verify --deep --strict --verbose=4 "${{ matrix.dist-path }}" 2>&1 | tee /tmp/codesign_verify.log; then
            echo "✓ Code signature seal is intact and valid"
          else
            echo "❌ ERROR: Code signature seal is broken - app will show as damaged"
            echo "Verification output:"
            cat /tmp/codesign_verify.log
            exit 1
          fi
          echo ""
          echo "=== Checking for unsigned components ==="
          find "${{ matrix.dist-path }}/Contents" -type f \( -name "*.dylib" -o -name "*.so" -o -name "*.framework" \) | while read file; do
            if ! codesign --verify "$file" 2>/dev/null; then
              echo "⚠ Unsigned: $file"
            fi
          done
          echo "✓ Component signature check complete"

      - name: Create archive (macOS)
        if: matrix.os == 'macos-latest'
        run: |
          cd dist
          # Preserve extended attributes and the stapled notarization ticket when archiving
          # --sequesterRsrc keeps resource forks/attrs that Gatekeeper expects
          ditto -c -k --sequesterRsrc --keepParent "$(basename ${{ matrix.dist-path }})" "../${{ matrix.archive-name }}"
          cd ..
          echo "Created archive: ${{ matrix.archive-name }}"
          ls -lh "${{ matrix.archive-name }}"
          
          # Verify the archive preserves the notarization ticket
          echo "Verifying notarization ticket in archive..."
          TEMP_VERIFY=$(mktemp -d)
          unzip -q "${{ matrix.archive-name }}" -d "$TEMP_VERIFY"
          APP_IN_ZIP=$(find "$TEMP_VERIFY" -name "*.app" -maxdepth 2 | head -1)
          if [ -n "$APP_IN_ZIP" ]; then
            xcrun stapler validate "$APP_IN_ZIP" || echo "⚠ Warning: Notarization ticket not preserved in archive"
            spctl --assess --type exec --verbose "$APP_IN_ZIP" || echo "⚠ Warning: Gatekeeper check failed for archived app"
          fi
          rm -rf "$TEMP_VERIFY"

      - name: Create archive (Linux)
        if: startsWith(matrix.os, 'ubuntu')
        run: |
          cd dist
          tar -czf "../${{ matrix.archive-name }}" "$(basename ${{ matrix.dist-path }})"
          cd ..

      - name: Create archive (Windows)
        if: startsWith(matrix.os, 'windows')
        run: |
          Compress-Archive -Path "${{ matrix.dist-path }}" -DestinationPath "${{ matrix.archive-name }}"
          Write-Host "Created archive: ${{ matrix.archive-name }}"
          Get-Item "${{ matrix.archive-name }}" | Format-List

      - name: Calculate and print SHA256 checksum
        run: |
          if [ "$RUNNER_OS" == "Windows" ]; then
            certutil -hashfile "${{ matrix.archive-name }}" SHA256
          elif [ "$RUNNER_OS" == "macOS" ]; then
            shasum -a 256 "${{ matrix.archive-name }}"
          else
            sha256sum "${{ matrix.archive-name }}"
          fi
        shell: bash

      - name: Upload artifact (Windows)
        if: startsWith(matrix.os, 'windows')
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.artifact-name }}
          path: ${{ matrix.archive-name }}
          if-no-files-found: error
          overwrite: true

      - name: Upload artifact (Linux/macOS)
        if: matrix.os != 'windows-latest'
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.artifact-name }}
          path: ${{ matrix.archive-name }}
          if-no-files-found: error
          overwrite: true
